# Project Flint: Backtesting Module (`backtest.py`)

## Overview

This module provides a sophisticated, professional-grade backtesting engine designed to rigorously evaluate the historical performance of trading strategies generated by Project Flint's machine learning models. It moves beyond simple accuracy metrics to simulate real-world trading conditions, providing a comprehensive and realistic assessment of a strategy's profitability and risk.

## Key Steps & Methodology

The backtesting process is executed via the `Backtester` class, which follows a robust, event-driven methodology:

1.  **Data Alignment:** It begins by aligning the historical price data (OHLCV), the model's probabilistic predictions, and the ATR (Average True Range) series onto a common, unified time-series index.
2.  **Signal Generation:** It converts the raw model probabilities into discrete trading signals (BUY, SELL, HOLD) based on a configurable threshold.
3.  **Vectorized Simulation:** The engine iterates through each day of the historical data, carrying forward the portfolio's state (cash, open positions, etc.).
4.  **Event-Driven Exits:** On each day, it first checks if any open positions have triggered a dynamic, ATR-based stop-loss or take-profit level. This event-driven logic ensures that risk management rules are respected before any new trades are considered.
5.  **Signal-Driven Entries:** If no position is currently open, the engine checks for a new trading signal for the current day. If a BUY or SELL signal is present, it executes a new trade.
6.  **Realistic Cost Modeling:** Every trade is subjected to configurable commission and slippage costs, ensuring the simulation accounts for real-world trading frictions.
7.  **Dynamic Position Sizing:** The size of each new position is calculated based on a fixed-fractional risk model, using the current portfolio equity and the ATR-based stop-loss to determine the number of shares.
8.  **Comprehensive Performance Reporting:** After the simulation is complete, it calculates and displays a full suite of professional performance metrics, including Sharpe Ratio, Sortino Ratio, Maximum Drawdown, and Profit Factor.

## Why This Approach is Superior

This backtesting module is a high-quality implementation because it avoids common pitfalls of naive backtesting:

-   **It is Realistic:** By modeling costs like commission and slippage, it provides a much more accurate picture of real-world performance than a simple signal-counting approach.
-   **It is Dynamic:** Using ATR for stop-loss and take-profit levels allows the strategy to adapt its risk management to the market's current volatility, which is superior to using fixed percentage stops.
-   **It is Comprehensive:** It evaluates strategies based on both profitability and risk (e.g., Sharpe Ratio, Max Drawdown), giving a complete view of a strategy's viability.
-   **It is Integrated:** It seamlessly consumes the outputs of the main analysis pipeline (`run.py`), allowing for rapid and consistent evaluation of different models and tickers.